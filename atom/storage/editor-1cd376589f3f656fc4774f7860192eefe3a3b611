{"mode":"editor","version":1,"windowDimensions":{"x":208,"y":22,"width":1024,"height":874},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4","buffers":[{"text":"# All Devise controllers are inherited from here.\nclass DeviseController < Devise.parent_controller.constantize\n  include Devise::Controllers::ScopedViews\n\n  helper DeviseHelper\n\n  helpers = %w(resource scope_name resource_name signed_in_resource\n               resource_class resource_params devise_mapping)\n  hide_action *helpers\n  helper_method *helpers\n\n  prepend_before_filter :assert_is_devise_resource!\n  respond_to :html if mimes_for_respond_to.empty?\n\n  # Gets the actual resource stored in the instance variable\n  def resource\n    instance_variable_get(:\"@#{resource_name}\")\n  end\n\n  # Proxy to devise map name\n  def resource_name\n    devise_mapping.name\n  end\n  alias :scope_name :resource_name\n\n  # Proxy to devise map class\n  def resource_class\n    devise_mapping.to\n  end\n\n  # Returns a signed in resource from session (if one exists)\n  def signed_in_resource\n    warden.authenticate(:scope => resource_name)\n  end\n\n  # Attempt to find the mapped route for devise based on request path\n  def devise_mapping\n    @devise_mapping ||= request.env[\"devise.mapping\"]\n  end\n\n  # Override prefixes to consider the scoped view.\n  # Notice we need to check for the request due to a bug in\n  # Action Controller tests that forces _prefixes to be\n  # loaded before even having a request object.\n  def _prefixes #:nodoc:\n    @_prefixes ||= if self.class.scoped_views? && request && devise_mapping\n      super.unshift(\"#{devise_mapping.scoped_path}/#{controller_name}\")\n    else\n      super\n    end\n  end\n\n  hide_action :_prefixes\n\n  protected\n\n  # Checks whether it's a devise mapped resource or not.\n  def assert_is_devise_resource! #:nodoc:\n    unknown_action! <<-MESSAGE unless devise_mapping\nCould not find devise mapping for path #{request.fullpath.inspect}.\nThis may happen for two reasons:\n\n1) You forgot to wrap your route inside the scope block. For example:\n\n  devise_scope :user do\n    get \"/some/route\" => \"some_devise_controller\"\n  end\n\n2) You are testing a Devise controller bypassing the router.\n   If so, you can explicitly tell Devise which mapping to use:\n\n   @request.env[\"devise.mapping\"] = Devise.mappings[:user]\n\nMESSAGE\n  end\n\n  # Returns real navigational formats which are supported by Rails\n  def navigational_formats\n    @navigational_formats ||= Devise.navigational_formats.select { |format| Mime::EXTENSION_LOOKUP[format.to_s] }\n  end\n\n  def unknown_action!(msg)\n    logger.debug \"[Devise] #{msg}\" if logger\n    raise AbstractController::ActionNotFound, msg\n  end\n\n  # Sets the resource creating an instance variable\n  def resource=(new_resource)\n    instance_variable_set(:\"@#{resource_name}\", new_resource)\n  end\n\n  # Helper for use in before_filters where no authentication is required.\n  #\n  # Example:\n  #   before_filter :require_no_authentication, :only => :new\n  def require_no_authentication\n    assert_is_devise_resource!\n    return unless is_navigational_format?\n    no_input = devise_mapping.no_input_strategies\n\n    authenticated = if no_input.present?\n      args = no_input.dup.push :scope => resource_name\n      warden.authenticate?(*args)\n    else\n      warden.authenticated?(resource_name)\n    end\n\n    if authenticated && resource = warden.user(resource_name)\n      flash[:alert] = I18n.t(\"devise.failure.already_authenticated\")\n      redirect_to after_sign_in_path_for(resource)\n    end\n  end\n\n  # Helper for use after calling send_*_instructions methods on a resource.\n  # If we are in paranoid mode, we always act as if the resource was valid\n  # and instructions were sent.\n  def successfully_sent?(resource)\n    notice = if Devise.paranoid\n      resource.errors.clear\n      :send_paranoid_instructions\n    elsif resource.errors.empty?\n      :send_instructions\n    end\n\n    if notice\n      set_flash_message :notice, notice if is_navigational_format?\n      true\n    end\n  end\n\n  # Sets the flash message with :key, using I18n. By default you are able\n  # to setup your messages using specific resource scope, and if no one is\n  # found we look to default scope.\n  # Example (i18n locale file):\n  #\n  #   en:\n  #     devise:\n  #       passwords:\n  #         #default_scope_messages - only if resource_scope is not found\n  #         user:\n  #           #resource_scope_messages\n  #\n  # Please refer to README or en.yml locale file to check what messages are\n  # available.\n  def set_flash_message(key, kind, options = {})\n    message = find_message(kind, options)\n    flash[key] = message if message.present?\n  end\n\n  # Get message for given\n  def find_message(kind, options = {})\n    options[:scope] = \"devise.#{controller_name}\"\n    options[:default] = Array(options[:default]).unshift(kind.to_sym)\n    options[:resource_name] = resource_name\n    options = devise_i18n_options(options) if respond_to?(:devise_i18n_options, true)\n    I18n.t(\"#{options[:resource_name]}.#{kind}\", options)\n  end\n\n  def clean_up_passwords(object)\n    object.clean_up_passwords if object.respond_to?(:clean_up_passwords)\n  end\n\n  def respond_with_navigational(*args, &block)\n    respond_with(*args) do |format|\n      format.any(*navigational_formats, &block)\n    end\n  end\n\n  def resource_params\n    params.fetch(resource_name, {})\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,1]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":34},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/app/controllers/devise_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"49adabf4df7d5d8fd38a8140d669a422383f0ed2","deserializer":"TextBuffer"},{"text":"module Devise\n  module Controllers\n    # Those helpers are convenience methods added to ApplicationController.\n    module Helpers\n      extend ActiveSupport::Concern\n\n      included do\n        helper_method :warden, :signed_in?, :devise_controller?\n      end\n\n      module ClassMethods\n        def log_process_action(payload)\n          payload[:status] ||= 401 unless payload[:exception]\n          super\n        end\n      end\n\n      # Define authentication filters and accessor helpers based on mappings.\n      # These filters should be used inside the controllers as before_filters,\n      # so you can control the scope of the user who should be signed in to\n      # access that specific controller/action.\n      # Example:\n      #\n      #   Roles:\n      #     User\n      #     Admin\n      #\n      #   Generated methods:\n      #     authenticate_user!  # Signs user in or redirect\n      #     authenticate_admin! # Signs admin in or redirect\n      #     user_signed_in?     # Checks whether there is a user signed in or not\n      #     admin_signed_in?    # Checks whether there is an admin signed in or not\n      #     current_user        # Current signed in user\n      #     current_admin       # Current signed in admin\n      #     user_session        # Session data available only to the user scope\n      #     admin_session       # Session data available only to the admin scope\n      #\n      #   Use:\n      #     before_filter :authenticate_user!  # Tell devise to use :user map\n      #     before_filter :authenticate_admin! # Tell devise to use :admin map\n      #\n      def self.define_helpers(mapping) #:nodoc:\n        mapping = mapping.name\n\n        class_eval <<-METHODS, __FILE__, __LINE__ + 1\n          def authenticate_#{mapping}!(opts={})\n            opts[:scope] = :#{mapping}\n            warden.authenticate!(opts) if !devise_controller? || opts.delete(:force)\n          end\n\n          def #{mapping}_signed_in?\n            !!current_#{mapping}\n          end\n\n          def current_#{mapping}\n            @current_#{mapping} ||= warden.authenticate(:scope => :#{mapping})\n          end\n\n          def #{mapping}_session\n            current_#{mapping} && warden.session(:#{mapping})\n          end\n        METHODS\n\n        ActiveSupport.on_load(:action_controller) do\n          helper_method \"current_#{mapping}\", \"#{mapping}_signed_in?\", \"#{mapping}_session\"\n        end\n      end\n\n      # The main accessor for the warden proxy instance\n      def warden\n        request.env['warden']\n      end\n\n      # Return true if it's a devise_controller. false to all controllers unless\n      # the controllers defined inside devise. Useful if you want to apply a before\n      # filter to all controllers, except the ones in devise:\n      #\n      #   before_filter :my_filter, :unless => :devise_controller?\n      def devise_controller?\n        is_a?(DeviseController)\n      end\n\n      # Setup a param sanitizer to filter parameters using strong_parameters. See\n      # lib/devise/parameter_sanitizer.rb for more info. Override this\n      # method in your application controller to use your own parameter sanitizer.\n      def devise_parameter_sanitizer\n        @devise_parameter_sanitizer ||= if defined?(ActionController::StrongParameters)\n          Devise::ParameterSanitizer.new(resource_class, resource_name, params)\n        else\n          Devise::BaseSanitizer.new(resource_class, resource_name, params)\n        end\n      end\n\n      # Tell warden that params authentication is allowed for that specific page.\n      def allow_params_authentication!\n        request.env[\"devise.allow_params_authentication\"] = true\n      end\n\n      # Return true if the given scope is signed in session. If no scope given, return\n      # true if any scope is signed in. Does not run authentication hooks.\n      def signed_in?(scope=nil)\n        [ scope || Devise.mappings.keys ].flatten.any? do |_scope|\n          warden.authenticate?(:scope => _scope)\n        end\n      end\n\n      # Sign in a user that already was authenticated. This helper is useful for logging\n      # users in after sign up.\n      #\n      # All options given to sign_in is passed forward to the set_user method in warden.\n      # The only exception is the :bypass option, which bypass warden callbacks and stores\n      # the user straight in session. This option is useful in cases the user is already\n      # signed in, but we want to refresh the credentials in session.\n      #\n      # Examples:\n      #\n      #   sign_in :user, @user                      # sign_in(scope, resource)\n      #   sign_in @user                             # sign_in(resource)\n      #   sign_in @user, :event => :authentication  # sign_in(resource, options)\n      #   sign_in @user, :bypass => true            # sign_in(resource, options)\n      #\n      def sign_in(resource_or_scope, *args)\n        options  = args.extract_options!\n        scope    = Devise::Mapping.find_scope!(resource_or_scope)\n        resource = args.last || resource_or_scope\n\n        expire_session_data_after_sign_in!\n\n        if options[:bypass]\n          warden.session_serializer.store(resource, scope)\n        elsif warden.user(scope) == resource && !options.delete(:force)\n          # Do nothing. User already signed in and we are not forcing it.\n          true\n        else\n          warden.set_user(resource, options.merge!(:scope => scope))\n        end\n      end\n\n      # Sign out a given user or scope. This helper is useful for signing out a user\n      # after deleting accounts. Returns true if there was a logout and false if there\n      # is no user logged in on the referred scope\n      #\n      # Examples:\n      #\n      #   sign_out :user     # sign_out(scope)\n      #   sign_out @user     # sign_out(resource)\n      #\n      def sign_out(resource_or_scope=nil)\n        return sign_out_all_scopes unless resource_or_scope\n        scope = Devise::Mapping.find_scope!(resource_or_scope)\n        user = warden.user(:scope => scope, :run_callbacks => false) # If there is no user\n\n        warden.raw_session.inspect # Without this inspect here. The session does not clear.\n        warden.logout(scope)\n        warden.clear_strategies_cache!(:scope => scope)\n        instance_variable_set(:\"@current_#{scope}\", nil)\n\n        !!user\n      end\n\n      # Sign out all active users or scopes. This helper is useful for signing out all roles\n      # in one click. This signs out ALL scopes in warden. Returns true if there was at least one logout\n      # and false if there was no user logged in on all scopes.\n      def sign_out_all_scopes(lock=true)\n        users = Devise.mappings.keys.map { |s| warden.user(:scope => s, :run_callbacks => false) }\n\n        warden.raw_session.inspect\n        warden.logout\n        expire_devise_cached_variables!\n        warden.clear_strategies_cache!\n        warden.lock! if lock\n\n        users.any?\n      end\n\n      # Returns and delete (if it's navigational format) the url stored in the session for\n      # the given scope. Useful for giving redirect backs after sign up:\n      #\n      # Example:\n      #\n      #   redirect_to stored_location_for(:user) || root_path\n      #\n      def stored_location_for(resource_or_scope)\n        scope = Devise::Mapping.find_scope!(resource_or_scope)\n\n        if is_navigational_format?\n          session.delete(\"#{scope}_return_to\")\n        else\n          session[\"#{scope}_return_to\"]\n        end\n      end\n\n      # The scope root url to be used when he's signed in. By default, it first\n      # tries to find a resource_root_path, otherwise it uses the root_path.\n      def signed_in_root_path(resource_or_scope)\n        scope = Devise::Mapping.find_scope!(resource_or_scope)\n        home_path = \"#{scope}_root_path\"\n        if respond_to?(home_path, true)\n          send(home_path)\n        elsif respond_to?(:root_path)\n          root_path\n        else\n          \"/\"\n        end\n      end\n\n      # The default url to be used after signing in. This is used by all Devise\n      # controllers and you can overwrite it in your ApplicationController to\n      # provide a custom hook for a custom resource.\n      #\n      # By default, it first tries to find a valid resource_return_to key in the\n      # session, then it fallbacks to resource_root_path, otherwise it uses the\n      # root path. For a user scope, you can define the default url in\n      # the following way:\n      #\n      #   map.user_root '/users', :controller => 'users' # creates user_root_path\n      #\n      #   map.namespace :user do |user|\n      #     user.root :controller => 'users' # creates user_root_path\n      #   end\n      #\n      # If the resource root path is not defined, root_path is used. However,\n      # if this default is not enough, you can customize it, for example:\n      #\n      #   def after_sign_in_path_for(resource)\n      #     stored_location_for(resource) ||\n      #       if resource.is_a?(User) && resource.can_publish?\n      #         publisher_url\n      #       else\n      #         super\n      #       end\n      #   end\n      #\n      def after_sign_in_path_for(resource_or_scope)\n        stored_location_for(resource_or_scope) || signed_in_root_path(resource_or_scope)\n      end\n\n      # Method used by sessions controller to sign out a user. You can overwrite\n      # it in your ApplicationController to provide a custom hook for a custom\n      # scope. Notice that differently from +after_sign_in_path_for+ this method\n      # receives a symbol with the scope, and not the resource.\n      #\n      # By default it is the root_path.\n      def after_sign_out_path_for(resource_or_scope)\n        respond_to?(:root_path) ? root_path : \"/\"\n      end\n\n      # Sign in a user and tries to redirect first to the stored location and\n      # then to the url specified by after_sign_in_path_for. It accepts the same\n      # parameters as the sign_in method.\n      def sign_in_and_redirect(resource_or_scope, *args)\n        options  = args.extract_options!\n        scope    = Devise::Mapping.find_scope!(resource_or_scope)\n        resource = args.last || resource_or_scope\n        sign_in(scope, resource, options)\n        redirect_to after_sign_in_path_for(resource)\n      end\n\n      def expire_session_data_after_sign_in!\n        session.keys.grep(/^devise\\./).each { |k| session.delete(k) }\n      end\n\n      # Sign out a user and tries to redirect to the url specified by\n      # after_sign_out_path_for.\n      def sign_out_and_redirect(resource_or_scope)\n        scope = Devise::Mapping.find_scope!(resource_or_scope)\n        redirect_path = after_sign_out_path_for(scope)\n        Devise.sign_out_all_scopes ? sign_out : sign_out(scope)\n        redirect_to redirect_path\n      end\n\n      # Overwrite Rails' handle unverified request to sign out all scopes,\n      # clear run strategies and remove cached variables.\n      def handle_unverified_request\n        sign_out_all_scopes(false)\n        request.env[\"devise.skip_storage\"] = true\n        expire_devise_cached_variables!\n        super # call the default behaviour which resets the session\n      end\n\n      def request_format\n        @request_format ||= request.format.try(:ref)\n      end\n\n      def is_navigational_format?\n        Devise.navigational_formats.include?(request_format)\n      end\n\n      private\n\n      def expire_devise_cached_variables!\n        Devise.mappings.each { |_,m| instance_variable_set(\"@current_#{m.name}\", nil) }\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":36},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/lib/devise/controllers/helpers.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"cbea74eefa3e71de49282bfe4b158a35181ee0b2","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":34,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":35,"softWrap":false,"editorWidthInChars":101,"tokenizedBuffer":{"bufferPath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/app/controllers/devise_controller.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":36,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":37,"softWrap":false,"editorWidthInChars":101,"tokenizedBuffer":{"bufferPath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/lib/devise/controllers/helpers.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/app/controllers/devise_controller.rb","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"command-logger":{"eventLog":{"project-find:show":{"count":1,"name":"project-find:show","lastRun":1396706871156}}},"find-and-replace":{"projectViewState":{"findHistory":["current_user"],"replaceHistory":[],"pathsHistory":[],"modelState":{"useRegex":false,"caseSensitive":false}},"resultsModelState":{"useRegex":false,"caseSensitive":false}},"fuzzy-finder":{"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/app/controllers/devise_controller.rb":1396707326984,"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/lib/devise/controllers/helpers.rb":1396707012308},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":459322},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/devise-3.0.4/app","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}