{"mode":"editor","version":"0.75.0","windowDimensions":{"x":208,"y":22,"width":1024,"height":874},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/spree_core-2.1.4","buffers":[{"text":"require 'spree/core/validators/email'\nrequire 'spree/order/checkout'\n\nmodule Spree\n  class Order < ActiveRecord::Base\n    include Checkout\n\n    checkout_flow do\n      go_to_state :address\n      go_to_state :delivery\n      go_to_state :payment, if: ->(order) {\n        order.update_totals\n        order.payment_required?\n      }\n      go_to_state :confirm, if: ->(order) { order.confirmation_required? }\n      go_to_state :complete\n      remove_transition from: :delivery, to: :confirm\n    end\n\n    token_resource\n\n    attr_reader :coupon_code\n\n    if Spree.user_class\n      belongs_to :user, class_name: Spree.user_class.to_s\n      belongs_to :created_by, class_name: Spree.user_class.to_s\n    else\n      belongs_to :user\n      belongs_to :created_by\n    end\n\n    belongs_to :bill_address, foreign_key: :bill_address_id, class_name: 'Spree::Address'\n    alias_attribute :billing_address, :bill_address\n\n    belongs_to :ship_address, foreign_key: :ship_address_id, class_name: 'Spree::Address'\n    alias_attribute :shipping_address, :ship_address\n\n    has_many :state_changes, as: :stateful\n    has_many :line_items, -> { order('created_at ASC') }, dependent: :destroy\n    has_many :payments, dependent: :destroy\n    has_many :return_authorizations, dependent: :destroy\n    has_many :adjustments, -> { order(\"#{Adjustment.table_name}.created_at ASC\") }, as: :adjustable, dependent: :destroy\n    has_many :line_item_adjustments, through: :line_items, source: :adjustments\n    has_many :all_adjustments, class_name: 'Spree::Adjustment'\n    has_many :inventory_units\n\n    has_many :shipments, dependent: :destroy do\n      def states\n        pluck(:state).uniq\n      end\n    end\n\n    accepts_nested_attributes_for :line_items\n    accepts_nested_attributes_for :bill_address\n    accepts_nested_attributes_for :ship_address\n    accepts_nested_attributes_for :payments\n    accepts_nested_attributes_for :shipments\n\n    # Needs to happen before save_permalink is called\n    before_validation :set_currency\n    before_validation :generate_order_number, on: :create\n    before_validation :clone_billing_address, if: :use_billing?\n    attr_accessor :use_billing\n\n    before_create :link_by_email\n    after_create :create_tax_charge!\n\n    validates :email, presence: true, if: :require_email\n    validates :email, email: true, if: :require_email, allow_blank: true\n    validate :has_available_shipment\n    validate :has_available_payment\n\n    make_permalink field: :number\n\n    class_attribute :update_hooks\n    self.update_hooks = Set.new\n\n    def self.by_number(number)\n      where(number: number)\n    end\n\n    def self.between(start_date, end_date)\n      where(created_at: start_date..end_date)\n    end\n\n    def self.by_customer(customer)\n      joins(:user).where(\"#{Spree.user_class.table_name}.email\" => customer)\n    end\n\n    def self.by_state(state)\n      where(state: state)\n    end\n\n    def self.complete\n      where.not(completed_at: nil)\n    end\n\n    def self.incomplete\n      where(completed_at: nil)\n    end\n\n    # Use this method in other gems that wish to register their own custom logic\n    # that should be called after Order#update\n    def self.register_update_hook(hook)\n      self.update_hooks.add(hook)\n    end\n\n    # For compatiblity with Calculator::PriceSack\n    def amount\n      line_items.inject(0.0) { |sum, li| sum + li.amount }\n    end\n\n    def currency\n      self[:currency] || Spree::Config[:currency]\n    end\n\n    def display_outstanding_balance\n      Spree::Money.new(outstanding_balance, { currency: currency })\n    end\n\n    def display_item_total\n      Spree::Money.new(item_total, { currency: currency })\n    end\n\n    def display_adjustment_total\n      Spree::Money.new(adjustment_total, { currency: currency })\n    end\n\n    def display_tax_total\n      Spree::Money.new(tax_total, { currency: currency })\n    end\n\n    def display_ship_total\n      Spree::Money.new(ship_total, { currency: currency })\n    end\n\n    def display_total\n      Spree::Money.new(total, { currency: currency })\n    end\n\n    def to_param\n      number.to_s.to_url.upcase\n    end\n\n    def completed?\n      completed_at.present? || complete?\n    end\n\n    # Indicates whether or not the user is allowed to proceed to checkout.\n    # Currently this is implemented as a check for whether or not there is at\n    # least one LineItem in the Order.  Feel free to override this logic in your\n    # own application if you require additional steps before allowing a checkout.\n    def checkout_allowed?\n      line_items.count > 0\n    end\n\n    # Is this a free order in which case the payment step should be skipped\n    def payment_required?\n      total.to_f > 0.0\n    end\n\n    # If true, causes the confirmation step to happen during the checkout process\n    def confirmation_required?\n      Spree::Config[:always_include_confirm_step] ||\n        payments.valid.map(&:payment_method).compact.any?(&:payment_profiles_supported?) ||\n        # Little hacky fix for #4117\n        # If this wasn't here, order would transition to address state on confirm failure\n        # because there would be no valid payments any more.\n        state == 'confirm'\n    end\n\n    # Indicates the number of items in the order\n    def item_count\n      line_items.inject(0) { |sum, li| sum + li.quantity }\n    end\n\n    def backordered?\n      shipments.any?(&:backordered?)\n    end\n\n    # Returns the relevant zone (if any) to be used for taxation purposes.\n    # Uses default tax zone unless there is a specific match\n    def tax_zone\n      Zone.match(tax_address) || Zone.default_tax\n    end\n\n    # Indicates whether tax should be backed out of the price calcualtions in\n    # cases where prices include tax but the customer is not required to pay\n    # taxes in that case.\n    def exclude_tax?\n      return false unless Spree::Config[:prices_inc_tax]\n      return tax_zone != Zone.default_tax\n    end\n\n    # Returns the address for taxation based on configuration\n    def tax_address\n      Spree::Config[:tax_using_ship_address] ? ship_address : bill_address\n    end\n\n    # Array of totals grouped by Adjustment#label. Useful for displaying line item\n    # adjustments on an invoice. For example, you can display tax breakout for\n    # cases where tax is included in price.\n    def line_item_adjustment_totals\n      Hash[self.line_item_adjustments.eligible.group_by(&:label).map do |label, adjustments|\n        total = adjustments.sum(&:amount)\n        [label, Spree::Money.new(total, { currency: currency })]\n      end]\n    end\n\n    def updater\n      @updater ||= OrderUpdater.new(self)\n    end\n\n    def update!\n      updater.update\n    end\n\n    def update_totals\n      updater.update_totals\n    end\n\n    def clone_billing_address\n      if bill_address and self.ship_address.nil?\n        self.ship_address = bill_address.clone\n      else\n        self.ship_address.attributes = bill_address.attributes.except('id', 'updated_at', 'created_at')\n      end\n      true\n    end\n\n    def allow_cancel?\n      return false unless completed? and state != 'canceled'\n      shipment_state.nil? || %w{ready backorder pending}.include?(shipment_state)\n    end\n\n    def awaiting_returns?\n      return_authorizations.any? { |return_authorization| return_authorization.authorized? }\n    end\n\n    def contents\n      @contents ||= Spree::OrderContents.new(self)\n    end\n\n    # Associates the specified user with the order.\n    def associate_user!(user)\n      self.user = user\n      self.email = user.email\n      self.created_by = user if self.created_by.blank?\n\n      if persisted?\n        # immediately persist the changes we just made, but don't use save since we might have an invalid address associated\n        self.class.unscoped.where(id: id).update_all(email: user.email, user_id: user.id, created_by_id: self.created_by_id)\n      end\n    end\n\n    # FIXME refactor this method and implement validation using validates_* utilities\n    def generate_order_number\n      record = true\n      while record\n        random = \"R#{Array.new(9){rand(9)}.join}\"\n        record = self.class.where(number: random).first\n      end\n      self.number = random if self.number.blank?\n      self.number\n    end\n\n    def shipped_shipments\n      shipments.shipped\n    end\n\n    def contains?(variant)\n      find_line_item_by_variant(variant).present?\n    end\n\n    def quantity_of(variant)\n      line_item = find_line_item_by_variant(variant)\n      line_item ? line_item.quantity : 0\n    end\n\n    def find_line_item_by_variant(variant)\n      line_items.detect { |line_item| line_item.variant_id == variant.id }\n    end\n\n    def ship_total\n      adjustments.shipping.sum(:amount)\n    end\n\n    # Creates new tax charges if there are any applicable rates. If prices already\n    # include taxes then price adjustments are created instead.\n    def create_tax_charge!\n      Spree::TaxRate.adjust(self)\n    end\n\n    def outstanding_balance\n      total - payment_total\n    end\n\n    def outstanding_balance?\n     self.outstanding_balance != 0\n    end\n\n    def name\n      if (address = bill_address || ship_address)\n        \"#{address.firstname} #{address.lastname}\"\n      end\n    end\n\n    def can_ship?\n      self.complete? || self.resumed? || self.awaiting_return? || self.returned?\n    end\n\n    def credit_cards\n      credit_card_ids = payments.from_credit_card.pluck(:source_id).uniq\n      CreditCard.where(id: credit_card_ids)\n    end\n\n    # Finalizes an in progress order after checkout is complete.\n    # Called after transition to complete state when payments will have been processed\n    def finalize!\n      touch :completed_at\n\n      # lock all adjustments (coupon promotions, etc.)\n      adjustments.update_all state: 'closed'\n\n      # update payment and shipment(s) states, and save\n      updater.update_payment_state\n      shipments.each do |shipment|\n        shipment.update!(self)\n        shipment.finalize!\n      end\n\n      updater.update_shipment_state\n      save\n      updater.run_hooks\n\n      deliver_order_confirmation_email\n    end\n\n    def deliver_order_confirmation_email\n      begin\n        OrderMailer.confirm_email(self.id).deliver\n      rescue Exception => e\n        logger.error(\"#{e.class.name}: #{e.message}\")\n        logger.error(e.backtrace * \"\\n\")\n      end\n    end\n\n    # Helper methods for checkout steps\n    def paid?\n      payment_state == 'paid' || payment_state == 'credit_owed'\n    end\n\n    def available_payment_methods\n      @available_payment_methods ||= (PaymentMethod.available(:front_end) + PaymentMethod.available(:both)).uniq\n    end\n\n    def pending_payments\n      payments.select(&:checkout?)\n    end\n\n    # processes any pending payments and must return a boolean as it's\n    # return value is used by the checkout state_machine to determine\n    # success or failure of the 'complete' event for the order\n    #\n    # Returns:\n    # - true if all pending_payments processed successfully\n    # - true if a payment failed, ie. raised a GatewayError\n    #   which gets rescued and converted to TRUE when\n    #   :allow_checkout_gateway_error is set to true\n    # - false if a payment failed, ie. raised a GatewayError\n    #   which gets rescued and converted to FALSE when\n    #   :allow_checkout_on_gateway_error is set to false\n    #\n    def process_payments!\n      if pending_payments.empty?\n        raise Core::GatewayError.new Spree.t(:no_pending_payments)\n      else\n        pending_payments.each do |payment|\n          break if payment_total >= total\n\n          payment.process!\n\n          if payment.completed?\n            self.payment_total += payment.amount\n          end\n        end\n      end\n    rescue Core::GatewayError => e\n      result = !!Spree::Config[:allow_checkout_on_gateway_error]\n      errors.add(:base, e.message) and return result\n    end\n\n    def billing_firstname\n      bill_address.try(:firstname)\n    end\n\n    def billing_lastname\n      bill_address.try(:lastname)\n    end\n\n    def products\n      line_items.map(&:product)\n    end\n\n    def variants\n      line_items.map(&:variant)\n    end\n\n    def insufficient_stock_lines\n      line_items.select &:insufficient_stock?\n    end\n\n    def merge!(order, user = nil)\n      order.line_items.each do |line_item|\n        next unless line_item.currency == currency\n        current_line_item = self.line_items.find_by(variant: line_item.variant)\n        if current_line_item\n          current_line_item.quantity += line_item.quantity\n          current_line_item.save\n        else\n          line_item.order_id = self.id\n          line_item.save\n        end\n      end\n\n      self.associate_user!(user) if !self.user && !user.blank?\n\n      # So that the destroy doesn't take out line items which may have been re-assigned\n      order.line_items.reload\n      order.destroy\n    end\n\n    def empty!\n      adjustments.destroy_all\n      line_items.destroy_all\n    end\n\n    def clear_adjustments!\n      self.adjustments.destroy_all\n      self.line_item_adjustments.destroy_all\n    end\n\n    def has_step?(step)\n      checkout_steps.include?(step)\n    end\n\n    def state_changed(name)\n      state = \"#{name}_state\"\n      if persisted?\n        old_state = self.send(\"#{state}_was\")\n        new_state = self.send(state)\n        unless old_state == new_state\n          self.state_changes.create(\n            previous_state: old_state,\n            next_state:     new_state,\n            name:           name,\n            user_id:        self.user_id\n          )\n        end\n      end\n    end\n\n    def coupon_code=(code)\n      @coupon_code = code.strip.downcase rescue nil\n    end\n\n    # Tells us if there if the specified promotion is already associated with the order\n    # regardless of whether or not its currently eligible. Useful because generally\n    # you would only want a promotion action to apply to order no more than once.\n    #\n    # Receives an adjustment +originator+ (here a PromotionAction object) and tells\n    # if the order has adjustments from that already\n    def promotion_credit_exists?(originator)\n      !! adjustments.includes(:originator).promotion.reload.detect { |credit| credit.originator.id == originator.id }\n    end\n\n    def promo_total\n      adjustments.eligible.promotion.sum(:amount)\n    end\n\n    def manual_adjustment_total\n      adjustments.eligible.manual.sum(:amount)\n    end\n\n    def discount_total\n      promo_total + manual_adjustment_total\n    end\n\n    def shipped?\n      %w(partial shipped).include?(shipment_state)\n    end\n\n    def create_proposed_shipments\n      adjustments.shipping.delete_all\n      shipments.destroy_all\n\n      packages = Spree::Stock::Coordinator.new(self).packages\n      packages.each do |package|\n        shipments << package.to_shipment\n      end\n\n      shipments\n    end\n\n    # Clean shipments and make order back to address state\n    #\n    # At some point the might need to force the order to transition from address\n    # to delivery again so that proper updated shipments are created.\n    # e.g. customer goes back from payment step and changes order items\n    def ensure_updated_shipments\n      if shipments.any?\n        self.shipments.destroy_all\n        restart_checkout_flow\n      end\n    end\n\n    def restart_checkout_flow\n      self.update_column(:state, checkout_steps.first)\n    end\n\n    def refresh_shipment_rates\n      shipments.map &:refresh_rates\n    end\n\n    def shipping_eq_billing_address?\n      (bill_address.empty? && ship_address.empty?) || bill_address.same_as?(ship_address)\n    end\n\n    def is_risky?\n      self.payments.where(%{\n        (avs_response IS NOT NULL and avs_response != 'D') or\n        (cvv_response_code IS NOT NULL and cvv_response_code != 'M') or\n        cvv_response_message IS NOT NULL or\n        state = 'failed'\n      }.squish!).uniq.count > 0\n    end\n\n    private\n\n      def link_by_email\n        self.email = user.email if self.user\n      end\n\n      # Determine if email is required (we don't want validation errors before we hit the checkout)\n      def require_email\n        return true unless new_record? or ['cart', 'address'].include?(state)\n      end\n\n      def ensure_line_items_present\n        unless line_items.present?\n          errors.add(:base, Spree.t(:there_are_no_items_for_this_order)) and return false\n        end\n      end\n\n      def has_available_shipment\n        return unless has_step?(\"delivery\")\n        return unless address?\n        return unless ship_address && ship_address.valid?\n        # errors.add(:base, :no_shipping_methods_available) if available_shipping_methods.empty?\n      end\n\n      def ensure_available_shipping_rates\n        if shipments.empty? || shipments.any? { |shipment| shipment.shipping_rates.blank? }\n          errors.add(:base, Spree.t(:items_cannot_be_shipped)) and return false\n        end\n      end\n\n      def has_available_payment\n        return unless delivery?\n        # errors.add(:base, :no_payment_methods_available) if available_payment_methods.empty?\n      end\n\n      def after_cancel\n        shipments.each { |shipment| shipment.cancel! }\n        payments.completed.each { |payment| payment.credit! }\n\n        send_cancel_email\n        self.update_column(:payment_state, 'credit_owed') unless shipped?\n      end\n\n      def send_cancel_email\n        OrderMailer.cancel_email(self.id).deliver\n      end\n\n      def after_resume\n        shipments.each { |shipment| shipment.resume! }\n      end\n\n      def use_billing?\n        @use_billing == true || @use_billing == 'true' || @use_billing == '1'\n      end\n\n      def set_currency\n        self.currency = Spree::Config[:currency] if self[:currency].nil?\n      end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[39,14],[39,21]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":12,"goalBufferRange":null,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/spree_core-2.1.4/app/models/spree/order.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"e4d542c0d16356a4f40af796be77d085808041bc","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":12,"softTabs":true,"scrollTop":2046,"scrollLeft":0,"displayBuffer":{"id":13,"softWrap":false,"editorWidthInChars":101,"tokenizedBuffer":{"bufferPath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/spree_core-2.1.4/app/models/spree/order.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/spree_core-2.1.4/app/models/spree/order.rb","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"command-logger":{"eventLog":{"find-and-replace:show":{"count":1,"name":"find-and-replace:show","lastRun":1395501807994},"symbols-view:toggle-file-symbols":{"count":1,"name":"symbols-view:toggle-file-symbols","lastRun":1395501809650}}},"find-and-replace":{"viewState":{"findHistory":["payment"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/spree_core-2.1.4/app/models/spree/order.rb":1395501798960},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":5852371},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/opt/boxen/rbenv/versions/2.0.0-p353/lib/ruby/gems/2.0.0/gems/spree_core-2.1.4","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}